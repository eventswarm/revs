#
# Maintain some patterns and alerts against the Log4J events generated by this app
#
require 'singleton'
require 'log4j-jar'
require 'eventswarm-jar'
require 'revs/email_sender'
require 'revs/log4_j_logger'
require 'revs/events'
require 'revs/tweet_stream'
require 'revs/brief_date'

java_import 'org.apache.log4j.BasicConfigurator'
java_import 'com.eventswarm.AddEventAction'
java_import 'com.eventswarm.events.LogEvent'
java_import 'com.eventswarm.eventset.LastNWindow'
java_import 'com.eventswarm.eventset.DiscreteTimeWindow'
java_import 'com.eventswarm.util.IntervalUnit'
java_import 'com.eventswarm.schedules.SystemClockTickTrigger'
java_import 'com.eventswarm.expressions.ExpressionMatchSet'
java_import 'com.eventswarm.expressions.MatchCountExpression'
java_import 'com.eventswarm.expressions.EventMatcherExpression'
java_import 'com.eventswarm.expressions.TrueTransition'
java_import 'com.eventswarm.util.logging.LevelThresholdMatcher'
java_import 'com.eventswarm.util.logging.LevelMatcher'
java_import 'com.eventswarm.util.logging.Log4JChannel'
java_import 'com.eventswarm.util.logging.MemoryMonitor'
java_import 'com.eventswarm.eventset.EveryNFilter'
java_import 'com.eventswarm.eventset.ThreadingPassThru'


class LogPatterns
  include Singleton
  include Log4JLogger
  include AddEventAction
  include Events

  attr_reader :last_n, :matches

  EMAIL_LIMIT = 50
  CONSOLE_LIMIT = 25
  SUBJECT_TEMPLATE = ERB.new "<%= AppConfig.app_name %> logging pattern matched at <%= url %>"
  TEXT_TEMPLATE = ERB.new <<EOF
<%= AppConfig.app_name %>  has matched a logging pattern. Relevant log event(s):

  <%= rendered_event %>

For full details, see log at <%= url %>.

Regards,

<%= AppConfig.sig_from %>
<%= AppConfig.sig_email %>
EOF

  def initialize

  end

  # setup a log4j appender and maintain at least count events in a LastNWindow
  def setup_channel(count=CONSOLE_LIMIT, email = AppConfig.reporting_email, base_url = AppConfig.base_url)
    # initialise email counter
    @count = 0
    # set up queued delivery of warnings etc in a separate thread
    @delivery_queue = ThreadingPassThru.new 1
    Triggers.add @delivery_queue, self
    # listen for log events with level of warning or higher
    logger.info "Setting up channel to collect log events"
    @channel = Log4JChannel.new
    @channel.threshold = Java::org.apache.log4j.Level::WARN
    logger.debug "Configuring log4j"
    BasicConfigurator.configure @channel
    # keep the last N incoming log events
    logger.debug "Setting up log event buffer"
    @last_n = LastNWindow.new count
    Triggers.add @channel, @last_n
    # maintain at least N matches
    logger.debug "Adding log event expressions"
    @matches = LastNWindow.new count
    add_expression *alert_on_errors
    add_expression *alert_on_warnings
    @base_url = base_url
    @sender = EmailSender.new email, base_url, nil, TEXT_TEMPLATE, SUBJECT_TEMPLATE
    Triggers.add @matches, @delivery_queue
    setup_always_report
  end

  def add_expression input, output
    logger.info "Adding #{input} to log event channel"
    Triggers.add @channel, input
    logger.info "Adding #{output} as a match trigger"
    Triggers.add_remove output, @matches
  end

  def reset_sender
    @sender.reset
  end

  def setup_always_report
    # Add configuration to collect log events that should always be reported (e.g. login/logout)
    @always_report = Log4JChannel.new
    @always_report.threshold = Java::org.apache.log4j.Level::INFO
    Log4JLogger::ALWAYS_REPORT.add_appender @always_report
    Triggers.add @always_report, @delivery_queue
    Triggers.add @always_report, @last_n
  end

  def setup_memory_monitor
    # configure memory monitor to check/report every 1000 tweets
    #@every_n = EveryNFilter.new 1000
    #TweetStream.register_action @every_n
    # configure memory monitor to check/report every 30 seconds
    @every_period = SystemClockTickTrigger.new(30000)
    @memory_monitor = MemoryMonitor.new
    Triggers.tick @every_period, @memory_monitor
    @memory_channel = Log4JChannel.new
    @memory_channel.threshold = Java::org.apache.log4j.Level::WARN
    Log4JLogger::MEMORY_MONITOR.add_appender @memory_channel
    Triggers.add @memory_channel, @delivery_queue
    Triggers.add @memory_channel, @last_n
  end

  # Alert when more than count errors have been reported in the specified time window (minutes)
  # If count is 1, the time window is ignored
  def alert_on_errors(count=1, window=10)
    wrap_expression EventMatcherExpression.new(LevelThresholdMatcher.new(LogEvent::Level::error)), count, window
  end

  #
  def alert_on_warnings(count=5, window=10)
    wrap_expression EventMatcherExpression.new(LevelMatcher.new(LogEvent::Level::warn)), count, window
  end

  def wrap_expression(expr, count, window)
    if count == 1
      # if we're matching singletons, no wrapping or window required
      [expr, expr]
    else
      # if we're matching more, filter with a time window and wrap with a count expression and a true transition
      input = DiscreteTimeWindow.new IntervalUnit::MINUTES, window
      wrapped_expr = TrueTransition.new(MatchCountExpression.new expr, count)
      Triggers.add_remove input, wrapped_expr
      [input, wrapped_expr]
    end
  end

  # send an alert when a trigger that we're listening to fires
  def execute(trigger, event, *args)
    @count = @count + 1
    logger.debug "Log pattern matcher has trigger #{trigger} and event #{event}"
    if @count < EMAIL_LIMIT
      begin
        if @broken
          logger.info "Previous log notifications failed, blocking further notifications"
        else
          @sender.send trigger, event, :size => 1, :url => @base_url, :rendered_event => render_log_event(event)
          @sender.reset
        end
      rescue Exception => ex
        @broken = true
        logger.error "Failed to send alert.", Java::org.jruby.exceptions.RaiseException.new(ex)
      end
    end
  end

  def render_log_event(event)
    if activity? event
      <<EOF
#{event.events.size} log events have matched:

#{event.events.collect {|log_event| '    ' + BriefDate.format(Time.at(log_event.header.timestamp.time/1000)) + ': ' + log_event.short_message }.join '\n'}
EOF
    else
      "    #{BriefDate.format(Time.at(event.header.timestamp.time/1000))}: #{event.short_message}"
    end
  end
end
